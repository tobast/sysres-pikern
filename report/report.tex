\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel} %% FRENCH, FIXME if typing in english
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

% Custom packages
\usepackage{my_listings}
\usepackage{my_hyperref}
\usepackage{math}

\author{Théophile \textsc{Bastian}, Nathanaël \textsc{Courant}}
\title{Systèmes et réseaux~: rendu de projet\\
{\small PiKern, un noyau minimaliste pour Raspberry Pi}}
\date{28 mai 2016}

\newcommand{\todo}[1]{\colorbox{orange}{\color{blue}{\Large TODO:} #1}}

\begin{document}
\maketitle

\begin{abstract}
Au cours de ce projet, nous nous sommes intéressés à l'écriture en C++ d'un
noyau minimaliste bootable pour Raspberry Pi. Nous avons réussi à implémenter
une gestion de processus distincts avec ordonnanceur, une couche réseau
complète gérant le ping et l'UDP, un système de fichiers en mémoire
pouvant contenir des fichiers éxécutables, un shell distant
minimaliste, ainsi que quelques jeux~: un serveur snake, et une
implantation basique de la Z-machine, permettant de jouer à un grand
nombre de jeux d'\textit{interactive fiction}, en particulier une
bonne partie des jeux publiés par Infocom.

	\todo{suite}
\end{abstract}

\begin{center}
	\href{https://github.com/tobast/sysres-pikern}
		{\Large \includegraphics[height=3em]{github.png}
		\raisebox{1em}{Code source}}
\end{center}

\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vue d'ensemble}

\subsection{organisation du code}

Tout le code source du noyau peut être trouvé sur Github
\href{https://github.com/tobast/sysres-pikern}{ici}, versionné.

Le code du noyau (dossier \texttt{kernel/src}) est organisé dans les fichiers
suivants~:

\begin{itemize}
	\item \texttt{arp}~: gestion des paquets ARP (découverte d'adresse MAC)~;
	\item \texttt{assert}~: gestion des assertions~;
	\item \texttt{atomic}~: opérations atomiques (mutex, \ldots)~;
	\item \texttt{barriers}~: barrières mémoire et d'instructions~;
	\item \texttt{Bytes}~: classe munie d'opérateurs << et >> pour gérer des
		octets en big endian, utilisé essentiellement pour le réseau~;
	\item \texttt{common}~: déclarations de types et de fonctions usuelles~;
	\item \texttt{exec\_context}~: contexte d'exécution d'un programme
		(stdin, stdout, working directory, \ldots)~;
	\item \texttt{expArray}~: équivalent à \lstcpp{std::vector}~;
	\item \texttt{filesystem}~: un RAMFS~;
	\item \texttt{format}~: formatteur sur le modèle de sprintf, pour des
		\texttt{Bytes}~;
	\item \texttt{fs\_populator}~: remplissage initial du RAMFS~;
	\item \texttt{genericSocket}~: classe de base pour les sockets (entre
		applications et réseau)~;
	\item \texttt{gpio}~: gestion des GPIOs (pins logiques matériels)~;
	\item \texttt{hardware\_constants}~: constantes dépendant de la version
		de Raspberry Pi utilisée~;
	\item \texttt{hashTable}~: une table de hachage~;
	\item \texttt{icmp}~: gestion des paquets ICMP (actuellement, uniquement
		réponse au ping)~;
	\item \texttt{interrupts}~: gestion des interruptions~;
	\item \texttt{ipv4}~: gestion de la couche IPv4~;
	\item \texttt{logger}~: interface de logs via le réseau~;
	\item \texttt{mailbox}~: gestion du protocole \textit{mailbox}, permettant
		de dialoguer avec le matériel (récupération de l'adresse MAC, 
		de la température des composants, de gérer l'alimentation des
		composants, \ldots)~;
	\item \texttt{malloc}~: malloc naïf (\lstc{sbrk})~;
	\item \texttt{networkCore}~: cœur de gestion du réseau~;
	\item \texttt{pair}~: équivalent à \lstcpp{std::pair}~;
	\item \texttt{pool\_allocator}~: malloc/free de taille constante, utilisé
		dans la gestion des sockets inter-process (code mort~?)~;
	\item \texttt{process}~: gestion des processus et des SVC~;
	\item \texttt{queue}~: équivalent à \lstcpp{std::queue}~;
	\item \texttt{sleep}~: gestion des \lstc{sleep}, et plus généralement
		du temps (timers, \ldots)~;
	\item \texttt{start\_message}~: contient une chaîne de caractères envoyée
		sur le réseau au boot~;
	\item \texttt{svc}~: appels SVC (appels système)~;
	\item \texttt{syslib}~: header pour les programmes indépendants~;
	\item \texttt{udp}~: gestion des paquets UDP~;
	\item \texttt{udpSocket}~: socket (héritant de \lstc{GenericSocket}
		spécialisé pour l'UDP~;
	\item \texttt{udpSysWrite}~: structure pour écrire de l'UDP sur le
		réseau depuis un programme indépendant~;
	\item \texttt{uspi\_interface}~: interfaçage avec USPi (driver USB).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bas niveau et matériel}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Processus}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Pour gérer plusieurs processus s'éxécutant en parallèle, on effectue
de la simulation séquentielle du parallélisme, en utilisant un seul
cœur du Raspberry Pi, qui éxécute séquentiellement des morceaux de
chaque processus.

Pour faire la transition entre chaque processus, il s'agit de
sauvegarder son état (i.e. l'état de tous ses registres et de son mode
uniquement, puisqu'il n'y a pas de MMU). On garde ces informations,
ainsi que quelques autres (état du processus, nom, répertoire
courant...) dans une table globale.

Les appels système se font par l'intermédiaire des intructions SVC,
qui font un appel au superviseur (et en particulier, changent le mode
du processeur~; c'est la seule manière de sortir du mode
\textit{user}). Il y a un type d'appel SVC pour chaque appel système
souhaité~; chacun d'entre eux ayant du code associé dans
\texttt{process.cpp}.

Les informations retenues pour chaque processus sont~:
\begin{itemize}
\item{l'état des registres et le mode,}
\item{les processus suivants et précédents dans la liste circulaire
  doublement chaînée des processus,}
\item{le répertoire courant,}
\item{l'état du processus~: actif, en train d'attendre de
  l'entrée-sortie, d'attendre la terminaison d'un autre processus,
  de dormir, ou zombi, ainsi qu'un entier 64 bits indiquant une
  information d'état (le moment de réveil pour un processus endormi,
  par exemple).}
\end{itemize}

Tout cela permet d'avoir des processus s'éxécutant en même temps, et
pouvant communiquer à travers les sockets existants. Cependant, il
y a une difficulté pour éxécuter des processus depuis un fichier.
\\

En effet, éxécuter un processus depuis un fichier requiert le
chargement du fichier en mémoire, et l'éxécution de celui-ci. Or, nous
n'avons pas de MMU, le fichier ne peut donc pas être facilement placé
à n'importe quel endroit de la mémoire. La solution pour cela est de
compiler les programmes avec l'option \texttt{-fPIC}, qui génère du
code indépendant de la position.

Cependant, ce code indépendant de la position a besoin d'une table
globale indiquant les positions des données. Pour ce faire, nous
ajoutons le décalage convenable aux variables dans la section
\texttt{.got} (Global Offset Table), ce qui permet d'avoir les
décalages voulus. Le format de l'en-tête d'un fichier éxécutable est
donc le suivant~:
\begin{itemize}
\item{constante magique \texttt{$\backslash{}$x7fELF} (4 octets),}
\item{fin de la section \texttt{.bss} (4 octets), permet de savoir la
  mémoire statique à allouer au processus,}
\item{position de la section \texttt{.got} (4 octets),}
\item{longueur (en mots de 4 octets) de la section \texttt{.got} (4 octets).\\}
\end{itemize}

Malgré cela, il semblerait qu'il reste quelques problèmes avec la
relocalisation des éxécutables~: ainsi, les exceptions et
l'utilisation de chaînes de caractères globales semblent poser
problème. Comme nous n'avions pas énormément de temps, et que le
format des fichiers produits par \texttt{gcc} est complexe, nous
n'avons pas cherché à corriger ces problèmes (ce qu'il faudrait bien
sûr faire dans un vrai système d'exploitation~!).

\section{Réseau}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Programmes indépendants}

\subsection{Commandes usuelles de shell}
\subsection{Interpréteur de ZMachine}
\subsection{Serveur de Snake multijoueur}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Difficultés rencontrées}

\subsection{Compilation du code}\label{ssec:diff:compil}
\todo{}
\subsection{Recoder la bibliothèque standard}\label{ssec:diff:stdlib}
\todo{}
\subsection{Écrasement de la table de vecteurs}\label{ssec:diff:delvect}
\todo{}
\subsection{Liaison C et C++ à la fois de malloc}\label{ssec:diff:linkage}
\todo{}
\subsection{\lstc{.text.startup} n'est pas au début}\label{ssec:diff:startup}
\todo{}
\subsection{Stack des processus mal placée}\label{ssec:diff:async_stack}
\todo{}

\end{document}

